# <center>Concurrent Programming Model</center>

<br>



#### 并行工作者模式
--------------
&#12288;&#12288;第一种并发模型是并行工作者模型。传入的作业会被分配到不同的工作者上：

<p align="center">
  <img src="./Images/pgm_model1.png"/>
</p>

&#12288;&#12288;在并行工作者模型中，委派者（Delegator）将作业分配给不同的工作者。工作者们并行运作在不同的线程上，甚至可能在不同CPU上。在Java中，并行工作者模型是最常见的并发模型。java.util.concurrent包中的许多是设计用于这个模型的。

&#12288;&#12288;并行工作者模式优点是很容易理解。只需添加更多的工作者来提高系统的并行度。

&#12288;&#12288;例如，如果做网络爬虫，可以使用不同数量的工作者抓取到一定数量的页面，然后看看多少数量的工作者消耗的时间最短（意味着性能最高）。由于网络爬虫是IO密集型工作，最终结果可能是你每个CPU或核心分配了几个线程。每个CPU若只分配一个线程可能少，因为在等待数据下载的过程中CPU将会空闲大量时间。

&#12288;&#12288;并行工作者模型缺点：
1. 共享状态可能会很复杂
2. 无状态的工作者。共享状态能被系统中其他线程修改。所以工作者在每次需要时须重读状态，以确保访问到最新的副本。工作者无法在内部保存这个状态（但是每次需要的时候可以重读）称为无状态的。每次都重读会导致速度变慢，特别是状态保存在外部数据库中的时候。
3. 任务顺序是不确定的。作业A可能在作业B之前就被分配工作者，但是作业B可能在作业A之前执行。

<br>



#### 流水线模式
-----------
&#12288;&#12288;第二种模型称为流水线并发模型，其他开发者可能会选择其他称呼（比如反应器系统或事件驱动系统）。

##### 流水线系统
<p align="center">
  <img src="./Images/pgm_model2.png"/>
</p>

<center><i>一个流水线并发模型</i></center>

<br>

&#12288;&#12288;通常使用非阻塞IO设计使用流水线并发模型系统。非阻塞IO意味着，某个工作者开始IO操作时（比如读取文件或从网络连接中读取数据），工作者不会一直等待IO操作结束。此时CPU做一些其他事情。当IO操作完成时，IO 操作的结果（比如读出的数据或者数据写完的状态）被传递给下一个工作者。

&#12288;&#12288;有了非阻塞 O，就可以使用IO操作确定工作者之间边界。工作者会尽可能多运行直到遇到并启动一个IO操作，然后交出作业控制权。

<p align="center">
  <img src="./Images/pgm_model3.png"/>
</p>

<br>


##### 反应器，事件驱动系统
&#12288;&#12288;流水线并发模型系统有时也称为反应器系统或事件驱动系统。系统内的工作者对系统内出现的事件做出反应，这些事件可能来自外部或其他工作者。事件可以是传入的HTTP请求，也可以是某个文件成功加载到内存中等。比较流行的是这几个：

* Vert.x (event-driven, non-blocking)
* AKKa (async, non-blocking, event-drivent, "let-it-crash" fault tolerance)
* Node.JS(JavaScript)

&#12288;&#12288;在Actor模型中每个工作者被称为actor。actor之间可直接异步地发送和处理消息。

<p align="center">
  <img src="./Images/actor1.png"/>
</p>

<center><i>Actor模型</i></center>

<br>

&#12288;&#12288;在Channel模型中，工作者之间不直接进行通信。它们在不同的通道中发布自己的消息（事件）。其他工作者们可以在这些通道上监听消息，发送者无需知道谁在监听，这使得工作者之间具有松散的耦合。

<p align="center">
  <img src="./Images/channel1.png"/>
</p>

<center><i>Channel模型</i></center>

<br>



#### 流水线模型优缺点
--------------
##### 优点

* 无需共享的状态

&#12288;&#12288;工作者之间无需共享状态，意味着实现的时候无需考虑所有因并发访问共享对象而产生的并发性问题。这使得在实现工作者的时候变得非常容易。在实现工作者的时候就好像是单个线程在处理工作-基本上是一个单线程的实现。

* 有状态的工作者

&#12288;&#12288;当工作者知道没有其他线程可以修改它们数据，工作者可以变成有状态的。对于有状态，指它们在内存中保存它们需要操作的数据，只需在最后将更改写回到外部存储系统。因此，有状态的工作者通常比无状态的工作者具有更高的性能。

* 较好的硬件整合（Hardware Conformity）

> 硬件整合是指，以某种方式编写的代码，使得能够自然地受益于底层硬件的工作原理。

&#12288;&#12288;单线程在整合底层硬件时具有更好的优势。

&#12288;&#12288;首先，当能确定代码只在单线程模式下执行的时候，能创建更优化的数据结构和算法。其次，单线程有状态的工作者能在内存中缓存数据。在内存中缓存数据同时，也意味着数据有可能缓存在执行这个线程的CPU缓存中。这使得访问缓存的数据变得更快。

* 合理的作业顺序

&#12288;&#12288;基于流水线并发模型实现的并发系统，在某种程度上是有可能保证作业的顺序的。作业的有序性使得它更容易地推出系统在某个特定时间点的状态。更进一步，可以将所有到达的作业写入到日志中去。一旦这个系统的某一部分挂掉了，该日志就可以用来重头开始重建系统当时的状态。按照特定的顺序将作业写入日志，并按这个顺序作为有保障的作业顺序。

&#12288;&#12288;实现一个有保障的作业顺序是不容易的。如果可以，将简化一些任务，例如备份、数据恢复、数据复制等，都可以通过日志文件来完成。

<br>


##### 缺点
&#12288;&#12288;最大的缺点是作业的执行分布到多个工作者上，并因此分布到项目中的多个类上。导致在追踪某个作业到底被什么代码执行时变得困难。同样，这也加大了代码编写的难度。有时会将工作者的代码写成回调处理的形式。若在代码中嵌入过多的回调处理，往往会出现所谓的回调地狱（callback hell）现象。

&#12288;&#12288;使用并行工作者模型可以简化这个问题。可以打开工作者代码，从头到尾阅读被执行的代码。当然并行工作者模式的代码也可能同样分布在不同的类中，但能够容易的从代码中分析执行的顺序。

<br>



#### 函数式并行（Functional Parallelism）
---------------
&#12288;&#12288;第三种并发模型是函数式并行模型。基本思想是采用函数调用实现程序。函数可以看作是”代理人（agents）“或”actor“，函数间可以像流水线模型（AKA 反应器或者事件驱动系统）那样互相发送消息。某个函数调用另一个函数，类似消息发送。

&#12288;&#12288;函数都是通过拷贝来传递参数，所以除了接收函数外没有实体可以操作数据。这对于避免共享数据的竞态来说是很有必要。同样也使得函数的执行类似于原子操作。每个函数调用的执行独立于任何其他函数的调用。一旦每个函数调用都可以独立执行，就可以分散在不同的CPU上执行。意味着能在多处理器上并行的执行使用函数式实现的算法。

&#12288;&#12288;Java 7中的java.util.concurrent包里包含的ForkAndJoinPool能够帮助实现类似于函数式并行的一些东西。Java 8中并行streams能用来帮助并行的迭代大型集合。

&#12288;&#12288;函数式并行里面最难的是确定需要并行的那个函数调用。跨CPU协调函数调用需一定开销。某个函数完成的工作单元需要达到某个大小以弥补这个开销。如果函数调用作用非常小，将它并行化可能比单线程、单CPU执行还慢。

&#12288;&#12288;此外，将任务拆分给多个CPU时协调造成的开销，仅在该任务是程序当前执行的唯一任务时才有意义。如果当前系统正在执行多个其他任务时（比如web服务器，数据库服务器），将单个任务进行并行化没有意义。不管怎样，其他CPU们都忙于处理其他任务，没有理由用一个慢的、函数式并行的任务去扰乱它们。使用流水线（反应器）并发模型会更好一点，因为它开销更小（在单线程模式下顺序执行）同时能更好的与底层硬件整合。

<br>



#### 使用那种并发模型最好？
---------------
&#12288;&#12288;如果作业本身就是并行的、独立的且没有必要共享状态，使用并行工作者模型去实现。虽然许多作业都不是自然并行和独立的。对于这种类型的系统，使用流水线并发模型能够更好的发挥它的优势，而且比并行工作者模型更有优势。
