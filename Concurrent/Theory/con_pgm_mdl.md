# <center>Concurrent Programming Model</center>



<br></br>

* 三种模型：
  1. 并行工作者 Master-Worker
    * 对于共享状态情况不利
    * 任务执行顺序不确定

  2. 流水线模式、事件驱动
    * AKKA，Node.JS
    * 在Actor模型中每个工作者被称为actor。actor之间可直接异步地发送和处理消息。
    * 在Channel模型中，工作者之间不直接进行通信，使得工作者之间具有松散的耦合。
    * 优点：无需共享状态、可以指定顺序、较好的硬件整合。
    * 缺点：代码跟踪和维护困难。

  3. 函数式并行
    * 函数间像流水线模型（AKKA反应器或事件驱动系统）那样互相发送消息。某个函数调用另一个函数，类似消息发送。
    * Java 7中的java.util.concurrent包里包含的ForkAndJoinPool能够帮助实现类似于函数式并行的一些东西。Java 8中并行streams能用来帮助并行的迭代大型集合。
    * 函数通过拷贝来传递参数，所以除了接收函数外没有实体可以操作数据。这对于避免共享数据的竞态来说是很有必要。也使得函数执行类似原子操作。


* 如果作业本身是并行、独立且没有共享状态，使用并行工作者模型。虽然许多作业都不是自然并行和独立的。对于这种类型的系统，使用流水线并发模型能够更好的发挥它的优势。

<br></br>



## 并行工作者模式
--------------
第一种并发模型是并行工作者模型。传入的作业会被分配到不同的工作者上：

<p align="center">
  <img src="./Images/pgm_model1.png"/>
</p>

<br>

在并行工作者模型中，委派者（Delegator）将作业分配给不同的工作者。在Java中，并行工作者模型是最常见的并发模型。java.util.concurrent包中的许多是设计用于这个模型的。

缺点：
1. 共享状态可能会很复杂。
2. 无状态的工作者。共享状态能被系统中其他线程修改，所以工作者在每次需要时须重读状态，以确保访问到最新的副本。工作者无法在内部保存这个状态（但是每次需要的时候可以重读）称为无状态的。每次都重读会导致速度变慢，特别是状态保存在外部数据库中的时候。
3. 任务顺序是不确定的。作业A可能在作业B之前就被分配工作者，但是作业B可能在作业A之前执行。

<br></br>



## 流水线模式
-----------
第二种模型称为流水线并发模型或反应器系统或事件驱动系统。

<br>


### 流水线系统
<p align="center">
  <img src="./Images/pgm_model2.png"/>
</p>

<center><i>一个流水线并发模型</i></center>

<br>

非阻塞IO设计使用流水线并发模型系统。

<p align="center">
  <img src="./Images/pgm_model3.png"/>
</p>

<br>


### 反应器，事件驱动系统
流水线并发模型系统有时也称为反应器系统或事件驱动系统。系统内的工作者对系统内出现的事件做出反应。比较流行的是这几个：

* Vert.x (event-driven, non-blocking)
* AKKA (async, non-blocking, event-drivent, "let-it-crash" fault tolerance)
* Node.JS(JavaScript)

在Actor模型中每个工作者被称为actor。actor之间可直接异步地发送和处理消息。

<p align="center">
  <img src="./Images/actor1.png"/>
</p>

<center><i>Actor模型</i></center>

<br>

在Channel模型中，工作者之间不直接进行通信。它们在不同的通道中发布自己的消息（事件）。其他工作者们可以在这些通道上监听消息，发送者无需知道谁在监听，这使得工作者之间具有松散的耦合。

<p align="center">
  <img src="./Images/channel1.png"/>
</p>

<center><i>Channel模型</i></center>

<br>


### 流水线模型优点

* 无需共享的状态

  工作者之间无需共享状态，意味着实现的时候无需考虑所有因并发访问共享对象而产生的并发性问题。这使得在实现工作者的时候变得非常容易。在实现工作者的时候就好像是单个线程在处理工作-基本上是一个单线程的实现。

* 有状态的工作者

  当工作者知道没有其他线程可以修改它们数据，工作者可以变成有状态的。对于有状态，指它们在内存中保存它们需要操作的数据，只需在最后将更改写回到外部存储系统。因此，有状态的工作者通常比无状态的工作者具有更高的性能。

* 较好的硬件整合（Hardware Conformity）

  硬件整合是指，以某种方式编写的代码，使得能够自然地受益于底层硬件的工作原理。
  
  单线程在整合底层硬件时具有更好的优势。

  首先，当能确定代码只在单线程模式下执行的时候，能创建更优化的数据结构和算法。其次，单线程有状态的工作者能在内存中缓存数据。在内存中缓存数据同时，也意味着数据有可能缓存在执行这个线程的CPU缓存中。这使得访问缓存的数据变得更快。

* 合理的作业顺序

  基于流水线并发模型实现的并发系统，在某种程度上是有可能保证作业的顺序的。作业的有序性使得它更容易地推出系统在某个特定时间点的状态。更进一步，可以将所有到达的作业写入到日志中去。一旦这个系统的某一部分挂掉了，该日志就可以用来重头开始重建系统当时的状态。按照特定的顺序将作业写入日志，并按这个顺序作为有保障的作业顺序。

<br>


### 缺点
作业的执行分布到多个工作者上，并因此分布到项目中的多个类上。导致在追踪某个作业到底被什么代码执行时变得困难，也加大了代码编写的难度

<br></br>



## 函数式并行（Functional Parallelism）
---------------
第三种并发模型是函数式并行模型。基本思想是采用函数调用实现程序。函数可以看作是”代理人（agents）“或”actor“，函数间可以像流水线模型（AKKA反应器或者事件驱动系统）那样互相发送消息。某个函数调用另一个函数，类似消息发送。

函数通过拷贝来传递参数，所以除了接收函数外没有实体可以操作数据。这对于避免共享数据的竞态来说是很有必要。也使得函数执行类似原子操作。每个函数调用的执行独立于任何其他函数的调用。一旦每个函数调用都可以独立执行，就可以分散在不同的CPU上执行。意味着能在多处理器上并行的执行使用函数式实现的算法。

Java 7中的java.util.concurrent包里包含的ForkAndJoinPool能够帮助实现类似于函数式并行的一些东西。Java 8中并行streams能用来帮助并行的迭代大型集合。

函数式并行里面最难的是确定需要并行的那个函数调用。跨CPU协调函数调用需一定开销。某个函数完成的工作单元需要达到某个大小以弥补这个开销。如果函数调用作用非常小，将它并行化可能比单线程、单CPU执行还慢。

此外，将任务拆分给多个CPU时协调造成的开销，仅在该任务是程序当前执行的唯一任务时才有意义。如果当前系统正在执行多个其他任务时（比如web服务器，数据库服务器），将单个任务进行并行化没有意义。不管怎样，其他CPU们都忙于处理其他任务，没有理由用一个慢的、函数式并行的任务去扰乱它们。使用流水线（反应器）并发模型会更好一点，因为它开销更小（在单线程模式下顺序执行）同时能更好的与底层硬件整合。

<br></br>
