# <center>Concurrent Model</center>

<br></br>



## 线程与锁并发模型
----
线程和锁模型其实是对底层硬件运行过程的形式化。

优点：
* 适用面广，对硬件工作方式的形式化，正确使用效率很高。可集成到多数编程语言中。

缺点：
* 没有为并行提供直接的支持（虽可通过改造成并发模式，但引入不确定的隐患）。只支持共享内存模型，如果要支持分布式内存模型，需其他帮助。
    
* 不易察觉的错误，如内存可见性。假如一种可能被乱序执行的方式访问内存。
    
* 可维护性差

<br></br>



## Actor模型
----
优点：
* 适用于解决多种并发问题，Actor可同时运行，但不共享状态。

* 关于并发，只需多个Actor之间消息流即可，便于调试。

* 天生的容错性，“let it crash”让代码简洁。

* 分布式编程，可解决任何规模的问题，地理分布式问题。

缺点：
* 虽比线程与锁模型易debug，但也有独有的问题，比如邮箱溢出。

* 由于不共享状态，仅通过消息进行交流，不适合细粒度并行。

Akka库为Java和JVM语言提供了对Actor模型的支持。

<br></br>



## 函数式编程
----
不适用可变状态，避免了线程与锁模型的许多缺陷。

优点：
* 可确信程序是按照预想方式运行。

* 比命令式程序，函数式更简单，易推理，便于测试。

* 由于函数式不使用可变状态，大部分存在线程和锁模型中的bug将销声匿迹。

缺点：
* 函数式代码比等价的命令式代码效率低。

<br></br>



## 通讯顺序进程（CSP）
----
CSP（Communicating Sequential Process）提供一种多个进程公用的“管道（channel）”，channel中存放一个个“任务”。

与Actor区别：
* Actor模型重点在于交流的实体，而CSP模型在于交流的通道。

* CSP是同步的，即任务被推送进channel就立即执行。如果任务线程正忙，则发送者暂时无法推送新任务。Actor是异步的。消息传递给Actor后并不一定马上执行。
    
* CSP中channel常是匿名的，即任务放进channel后不需知道哪个channel执行任务。而Actor有身份，可明确知道哪个Actor执行任务。换言之，使用Actor时，负责通讯的媒介与执行单元是紧耦合。

* CSP中，只通过channel在任务间传递消息；Actor中可直接从一个Actor往另一个Actor传输数据。
    
* CSP中消息的交互是同步的，Actor中支持异步的消息交互。
