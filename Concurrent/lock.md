# <center>JVM Lock</center>



<br></br>



## 自旋锁
----
在很多应用上，共享数据的锁定状态只会持续很短的时间。若有多个处理器能让两个以上的线程并行执行，可让后面请求锁的那个线程原地自旋（不放弃CPU时间），看持有锁的线程是否很快释放锁。为了让线程等待，只须让线程执行一个忙循环（自旋），这就是自旋锁。

如果锁长时间被占用，则浪费处理器资源，因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了（默认10次）。

<br></br>



## 锁削除，锁膨胀
----
锁削除指虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行削除（主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行）。

如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（膨胀）到整个操作序列的外部（由多次加锁编程只加锁一次）。

<br></br>



## 轻量级锁
----
轻量级锁不是用来代替重量级锁（传统锁机制，如互斥等），目的是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。

HotSpot虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄等，这部分数据的长度在32位和64位的虚拟机中分别为32个和64个Bits，称为Mark Word，是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。

<br>


### 加锁过程
进入同步块时，如果此同步对象没有被锁定（锁标志位为_01_状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（Displaced Mark Word），这时候线程堆栈与对象头的状态如下图所示：

<p align="center">
  <img src="./Images/lock1.png"/>
</p>

<br>

然后，虚拟机使用CAS操作将对象的Mark Word更新为指向Lock Record的指针。如果更新成功，那么线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个Bits）将转变为_00_，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图所示：

<p align="center">
  <img src="./Images/lock2.png"/>
</p>

<br>

如果更新操作失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧。如果是，说明线程已拥有了这个对象锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为_10_，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

<br>


### 解锁过程
解锁过程也是通过CAS。如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。

<br></br>



## 偏向锁
----
目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做。

偏向锁会偏向于第一个获得它的线程（Mark Word中的偏向线程ID信息），如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

假设JVM启用了偏向锁（-XX:+UseBiasedLocking），当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为_01_，即偏向模式。同时使用CAS把获取这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如Locking、Unlocking及对Mark Word的Update等）。当有另外一个线程去尝试获取这个锁时，偏向模式就结束。根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为_01_）或轻量级锁定（标志位为_00_）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。

<p align="center">
  <img src="./Images/lock3.png"/>
</p>
<center><i>偏向锁、轻量级锁的状态转化及对象Mark Word的关系</i></center>